% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fragBinary.r
\name{fragBinary}
\alias{fragBinary}
\title{Calculate fragmentation indices for a binary raster}
\usage{
fragBinary(
  rast,
  w = 3,
  pad = FALSE,
  padValue = NA,
  calcDensity = TRUE,
  calcConnect = TRUE,
  calcClass = TRUE,
  na.rm = FALSE,
  undet = "undetermined",
  cores = 1,
  ...
)
}
\arguments{
\item{rast}{\code{SpatRaster} with binary values (1 or 0 or \code{NA}).}

\item{w}{Integer, number of cells wide and high of the window used to calculate fragmentation. This must be an odd integer (default is 3).}

\item{pad}{Logical, if \code{TRUE} then add virtual rows and columns around the raster so that there are no edge effects. The virtual rows and columns are set to equal \code{padValue}. Default is \code{FALSE}.}

\item{padValue}{Value to which to set the values of the virtual cells used to pad the raster if \code{pad} is \code{TRUE}.}

\item{calcDensity}{Logical, if \code{TRUE} (default) then calculate density raster.}

\item{calcConnect}{Logical, if \code{TRUE} (default) then calculate connectivity raster.}

\item{calcClass}{Logical, if \code{TRUE} (default) then calculate classification raster. Note that to calculate the classification raster the density and connectivity rasters must also be calculated (\code{calcDensity} and \code{calcConnect} should both be \code{TRUE}). If they are not then the will be forced to \code{TRUE} with a warning.}

\item{na.rm}{Logical, if \code{FALSE} (default) then \code{NA} cells count as part of the area potentially occupied in a window (i.e., the count in the denominator when calculating density and they are counted as potential links in the connectance calculations if a neighboring cell has a value of 1). If \code{FALSE} then areas that border \code{NA} cells could still be classified as "interior" or otherwise have less apparent fragmentation if the occupied cells are fully surrounded by other occupied cells (except for the \code{NA} cells).}

\item{undet}{Character. When classifying this defines what is done with "undetermined" cases (when density is >= 0.6 and density == connectivity). Possible values include (partial matching of strings is used):
\itemize{
    \item \code{'undetermined'}: Undetermined cases will be assigned a value of 5 (which is not assigned to any other case; default).
    \item \code{'perforated'}: Undetermined cases will be assigned a value of 3 ("perforated").
    \item \code{'edge'}: Undetermined cases will be assigned a value of 4 ("edge").
    \item \code{'random'}: Undetermined cases will be assigned a value of 3 or 4 at random ("perforated" or "edge").
}}

\item{cores}{Number of processor cores to use. The default is to use 1.}

\item{...}{Other arguments (not used).}
}
\value{
A \code{SpatRaster} "stack" with three layers: 1) a fragmentation classification (named \code{class}); 2) the density of "1" pixels in the window (named \code{density}--called "pf" in Riitter et al. 2000); 3) and a connectivity raster (conditional probability a cell with a value of 1 has a value that is also 1 named \code{connect}--called "pff" in Riitter et al. 2000). The density and connectivity rasters have values in the range [0, 1], but the classification raster has coded values (from the erratum to Ritter et al. (2000):
\itemize{
	\item \code{NA}: \code{NA}
	\item \code{0}: No forest (or whatever is being evaluated)
\item \code{1}: patch (\code{pf} < 0.4)
\item \code{2}: transitional (0.4 <= \code{pf} < 0.6)
\item \code{3}: perforated (\code{pf} >= 0.6 & \code{pf - pff} > 0)
\item \code{4}: edge (\code{pf} >= 0.6 & \code{pf - pff} < 0)
\item \code{5}: undetermined (\code{pf} >= 0.6 & \code{pf == pff})
\item \code{6}: interior (\code{pf} == 1)
}
Note that this differs somewhat from the numbering scheme presented by Riitters et al. (2000) and their errata.
}
\description{
The function calculates a set of fragmentation indices as per Riitters et al. (2000).
}
\examples{
library(terra)

# forest cover
rastFile <- system.file('extdata', 'rocForest.tif', package='fragmentation')
roc <- rast(rastFile)

# increase number of cores to make it go faster
cores <- 2

# fragmentation: binary forest data
rocBinary <- roc > 80 # threshold to make it bonary

binary <- fragBinary(rocBinary, cores=cores)
plot(c(rocBinary, binary))

# fragmentation: continuous values with equally-spaced thresholds
contEqual <- fragCont(roc, thresholds=4, cores=cores, verbose=TRUE)
plot(contEqual)

# fragmentation: continuous values with user-defined thresholds
tr <- c(70, 80, 90) # user-defined thresholds
contUser <- fragCont(roc, thresholds=tr, cores=2, verbose=TRUE)
plot(contUser)
}
\references{
Riitters, K., J. Wickham, R. O'Neill, B. Jones, and E. Smith. 2000. Global-scale patterns of forest fragmentation. Conservation Ecology 4:3. \href{https://www.jstor.org/stable/26271763}{URL}. Also note the \href{https://www.ecologyandsociety.org/vol4/iss2/art3/errata/january26.2001.html}{errata} to the paper on their classification scheme.
}
\seealso{
\code{\link{fragCont}} for continuously-valued forest raster data
}
